---
layout: post
title: "Computational thinking"
date: "2021-03-13 15:00:56 +0000"
author: Miles Berry
permalink: /2021/03/computational-thinking/
comments: true
image:
        feature: 210313.jpg
---


Computational thinking owes its origins to a paper by Jeanette Wing (2006), which explored how some of the ideas and approaches of computer science could be applied to solving problems in other domains. This linkage to other contexts remains a common approach to introducing the elements of computational thinking in primary schools, for example through teaching the idea of an algorithm by having pupils give a sequence of instructions for making a jam sandwich. More recently, the link between computational thinking and computer programming has had more emphasis (e.g. Tedre and Denning, 2016), regarding computational thinking as an approach to problem solving which seeks to find an automated (i.e., programmable) solution to the problem.

Computational thinking makes use of a number of common strategies or concepts from computer science, such as abstraction, decomposition, generalisation and algorithms.

**Abstraction** is a powerful technique for managing the complexity of multi-layered systems, in which some layers of detail are set to one side, allowing the problem solver to focus on what is most relevant to the current task. For example, in recording a video, pupils might concentrate on their dialogue and actions, rather than attending to the technical detail of how individual frames are recorded or processed on the tablet or camera they are using. Similarly, when creating a computer game, pupils will typically focus on the objectives, rules and controls of their game, rather than creating photorealistic renders of the scene or character.

**Decomposition** is the process of breaking a problem down into smaller parts, before addressing each of these. In our video making example, pupils might break the big task of making a video down into component parts, perhaps dividing these amongst the members of a group or a team: the story, the script, costumes, settings, props, acting, filming, recording audio, editing etc. In making a game, pupils would decompose this big task into designing characters and background, handling input from the user, programming movement, working out scores, adding background music or sound effects and so on.

**Pattern recognition** or **generalisation** is the process of identifying which parts of a solution can be reused, either within the solution or by looking at how similar problems have been solved previously by others. Good computer programmers can be lazy, rarely creating new solutions from scratch when it is possible to reuse aspects of someone else’s tried and tested approach. In our movie making example, similar approaches to acting, filming and editing could be applied irrespective of the specifics of a particular project. Similarly, a maze game on a computer is likely to have similar underlying code irrespective of the particular characters, hazards or scoring the programmer selects. Developing as a computational thinker, and indeed as a programmer, involves extending the repertoire of patterns that can be drawn on.

**Algorithms** are sequences of instructions (or sometimes sets of rules) to achieve a particular objective. Computational thinking is concerned with finding an algorithm to solve a problem, or more often a class of similar problems. There are some important algorithms for problems such as searching a list for a particular matching value, sorting lists into order, finding the quickest route between two places on a map or deciding which webpages to list first when using a search engine. Pupils learn algorithms in maths lessons, such as those for column addition, for long multiplication or for adding fractions. Pupils might think of the dialogue and stage directions in a script as an example of an algorithm, or use the term to describe the sequence of moves a character would follow to escape from a maze, although here it would be better to think of the more general algorithm which would find a path through any maze.

Whilst there are many areas of the curriculum in which these computational thinking concepts can be applied (for example, levels of abstraction in maps in geography lessons, breaking tasks down into smaller sub-tasks in design and technology, repeating tunes or rhythms in music or the plan for a story in English lessons), these are perhaps best considered as analogies for how these concepts are applied to constructing automatable solutions to problems - it’s only when these problem solving approaches are applied to computable solutions that they become genuinely computational thinking. Without computation, computational thinking is just thinking.

## Reflection

Do these approaches apply to any problem solving activity, or do they only make sense when computers are involved? Is it better to teach these with concrete, real world examples, or should they always be linked to programming? Is the development of computational thinking sufficient as a justification for including so much computer science on the primary curriculum?

## References

Tedre, M. & Denning, P. J. 2016, '[The long quest for computational thinking](http://denninginstitute.com/pjd/PUBS/long-quest-ct.pdf)', *Proceedings of the 16th Koli Calling International Conference on Computing Education Research*, 120--129.

Wing, J. M. 2006, '[Computational thinking](http://www.cs.cmu.edu/~./15110-s13/Wing06-ct.pdf)', *Communications of the ACM*, 49, 3, 33--35.
