---
id: 1438
title: Computational thinking and mathematical reasoning
date: 2016-11-27T16:39:05+00:00
author: Miles Berry and Andrew Csizmadia
layout: post
guid: http://milesberry.net/?p=1438
permalink: /2016/11/computational-thinking-and-mathematical-reasoning/
categories:
  - Uncategorized
image:
    feature: 161127.jpg
---
<p class="p1" style="padding-left: 30px;">
  <em>Andrew Csizmadia and I presented on Computing: the silent C in STEM at a CIDREE expert group of STEM curriculum developers in Utrecht last week. Here&#8217;s an extract of our paper, exploring the connections between computational thinking and mathematical reasoning.</em>
</p>

<p class="p1">
  From primary school onwards, children’s arithmetic has two quite distinct stages: thinking about the question, and then working out the answer. A sum as simple as 23 + 39 demands that the child be able to decode these symbols in some meaningful way and determine which algorithm to bring to bear in order to calculate the answer: then, and only then, can the child go on to working out the answer. When faced with a word problem, for example, how much change will I receive from a 5 pound note if I buy three apples each costing 40 pence, the same two stages apply, this time demanding a degree of abstraction as the child moves from the particular context to its mathematical representation, in this case 5 &#8211; 3 x 0.40.
</p>

<p class="p2">
  <span class="s1">More generally, we might see that most, indeed perhaps all, mathematics mirrors these two stages &#8211; thinking about problems and then manipulating symbols according to rules (i.e. a more sophisticated version of working things out). The formalist view of mathematics is that mathematics consists of the consequences of certain string manipulation rules: for example Euclidean geometry can be thought of as those statements which can be formed by manipulating geometric axioms according to the laws of inference. However, even within this formalist paradigm, practical, useful mathematics demands some thinking about which particular manipulations of strings will take us towards the solution of the problem facing us.</span>
</p>

<p class="p2">
  <span class="s1">This view of mathematics as symbol manipulation lies at the foundation of computing. Up until the 1940s, <i>computer</i> was a job title &#8211; given to those paid to do arithmetic on paper or mechanical calculators according to the rules and procedures given them by their managers. Turing expressed this symbol manipulation view of mathematics in his seminal paper, <a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf"><span class="s2">‘On computable numbers, with an application to the Entscheidungsproblem’</span></a>, defining computable numbers as those which could be written down by a machine and generalising this to computable functions and computable predicates: it is on this work (and the <a href="http://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf"><span class="s2">parallel work of Alonzo Church</span></a>) that computer science is founded, and thus the strong connections between mathematics and computer science, from primary school level up should not surprise us.</span>
</p>

<p class="p2">
  <span class="s1">In the decades since Turing’s and Church’s work, mathematics, as with so many other fields, has been transformed by digital computing. The symbol-manipulation (or working out) phase of the mathematics done in science, finance, social sciences, the arts and every other domain (other than education) is done now by digital computers, rather than by people, as Conrad Wolfram explains in <a href="http://www.ted.com/talks/conrad_wolfram_teaching_kids_real_math_with_computers"><span class="s2">his TED talk</span></a>. Indeed much of the symbol manipulation of even pure mathematics is now often done by digital computers rather than mathematicians, or their research assistants, themselves (see, e.g., Appel and Haken’s computer-assisted </span><a href="http://projecteuclid.org/download/pdf_1/euclid.ijm/1256049011"><span class="s3">proof of the Four-Colour Theorem</span></a><span class="s1">.)</span>
</p>

<p class="p2">
  <span class="s1">The first phase of mathematics &#8211; thinking about the problem or the system &#8211; remains largely unchanged. Creative and imaginative problem solving lies at the heart of mathematics. Polya suggested four principles for problem solving: understand the problem, devise a plan, carry out the plan and look back, plus a number of associated heuristics.</span>
</p>


<figure>
<img src="http://4.bp.blogspot.com/-rW8XSQOyupo/UZEYSQrmuWI/AAAAAAAABiA/LlKtkGtPUA0/s1600/how-to-solve-it_Polya.jpg">
<figcaption>Polya: how to solve it</figcaption>
</figure>



<p class="p2">
  <span class="s4"><a href="https://www.computerbasedmath.org/assets/img/case-for-computer-based-math-education/CBM_brochure.pdf">Wolfram</a></span><span class="s1"> argues convincingly that this is what mathematics education should now focus on, given that actual computation is now done by machines, and suggests his own four-stage helix for problem solving: define questions, translate to maths, computer answers and interpret. There are parallels here with the development process in software engineering: specification, design, implementation and testing.</span>
</p>


<figure>
<img src="https://www.computerbasedmath.org/assets/img/case-for-computer-based-math-education/CBMManMovie.gif">
<figcaption>Computer Based Math</figcaption>
</figure>


<p class="p2">
  <span class="s1">It would be wrong to think of school mathematics as being confined to manual computation. Problem solving and mathematical reasoning is an essential part of mathematics education. For example, the <a href="https://www.gov.uk/government/collections/national-curriculum"><span class="s2">English National Curriculum</span></a> aims to ensure that all pupils:</span>
</p>

> <p class="p4">
>   <span class="s1"><i>reason mathematically by following a line of enquiry, conjecturing relationships and generalisations, and developing an argument, justification or proof using mathematical language; and</i></span>
> </p>
>
> <p class="p4">
>   <span class="s1"><i>can solve problems by applying their mathematics to a variety of routine and non-routine problems with increasing sophistication, including breaking down problems into a series of simpler steps and persevering in seeking solutions.</i></span>
> </p>

<p class="p2">
  <span class="s1">Given the strong connections between mathematics and computer science, it would be surprising if the sort of mathematical reasoning involved in understanding problems and planning their solution was not mirrored by similar thinking in specifying systems and designing solutions in the field of computing. Just as mathematics might be seen as thinking followed by symbol manipulation, so programming can be seen as <b>algorithms plus code</b>. Before programmers begin work on coding solutions, they need to have fully understood the problem and have a clear plan (an algorithm) of how to solve it.</span>
</p>

<p class="p2">
  <span class="s1">The term ‘computational thinking’ has been coined to describe</span>
</p>

> <p class="p4">
>   <span class="s1"><i>the thought processes involved in formulating problems and their solutions so that the solutions are represented in a form that can be effectively carried out by an information-processing agent. (</i><span class="s5"><i><a href="http://www.cs.cmu.edu/~CompThink/resources/TheLinkWing.pdf">Wing, 2010</a>)</i></span></span>
> </p>

<p class="p2">
  <span class="s1">Whilst there is not yet a universal consensus over the <a href="http://eprints.soton.ac.uk/356481/"><span class="s2">exact ingredients</span></a> of computational thinking, its importance in computing education is widely accepted. It is seen as a ‘golden thread’ running through the English <a href="https://www.gov.uk/government/publications/national-curriculum-in-england-computing-programmes-of-study"><span class="s2">National Curriculum for Computing</span></a>, which begins:</span>
</p>

> <p class="p4">
>   <span class="s1"><i>A high-quality computing education equips pupils to use computational thinking and creativity to understand and change the world. Computing has deep links with mathematics, science and design and technology, and provides insights into both natural and artificial systems.</i></span>
> </p>

<p class="p2">
  <span class="s1">Building on <a href="http://web.media.mit.edu/%7Ekbrennan/files/Brennan_Resnick_AERA2012_CT.pdf"><span class="s2">Brennan and Resinick’s work</span></a> in which computational thinking is explored as concepts, practices and perspectives, Computing At School’s <a href="http://barefootcas.org.uk/"><span class="s2">‘Barefoot Computing’</span></a> continuing professional development programme for primary teachers identified six concepts and five approaches for computational thinking (qv Computing At School’s <a href="http://primary.quickstartcomputing.org/resources/pdf/qs_handbook.pdf"><span class="s2">QuickStart Computing handbook</span></a>). The concepts provide a unified approach to problem solving in both mathematics and computing, with a number of the example activities produced for Barefoot Computing linking these to topics in the English mathematics curriculum.</span>
</p>



<figure>
<img src="http://barefootcas.org.uk/wp-content/uploads/2014/06/Barefoot-CT-Poster-for-website.jpg">
<figcaption>The computational thinker</figcaption>
</figure>



<ul class="ul1">
  <li class="li4">
    <strong><span class="s1">Logical reasoning</span></strong> <ul class="ul2">
      <li class="li4">
        <span class="s1">In computing pupils use laws of inference to predict what programs will do from their source code, to detect and correct errors in algorithms and programs and to analyse the efficiency and correctness of algorithms; pupils learn about Boolean logic and its applications to circuits, programs and search. Program execution by CPUs relies on logic gates.</span>
      </li>
      <li class="li4">
        <span class="s1">Mathematics is underpinned by set theory and logic. Mathematical reasoning is fundamentally logical reasoning. In maths, pupils will be expected to ‘show their working’ and to provide a justification for their answer. They form a basic understanding of sets and their relationship, which is later formalised through Venn diagrams and the notation of set theory. They are introduced to simple proof techniques in Euclidean geometry, and will use <i>reductio ad abusurdum</i> and induction at A level.</span>
      </li>
    </ul>
  </li>

  <li class="li4">
    <strong><span class="s1">Algorithms</span></strong> <ul class="ul2">
      <li class="li4">
        <span class="s1">From an early age, pupils learn about algorithms as sets of rules or sequences of steps for real life situations such as making a jam sandwich or tidying their classroom. They learn how these algorithms are implemented as code on digital devices. They learn that there are multiple algorithms for the same problem. They create their own algorithmic solutions to computational problems and are taught some classic algorithms for search and sort, finding greatest common divisors and testing for primality. They study greedy and divide-and-conquer algorithms in a range of contexts, including graph theory. They compare the efficiency of algorithms, in time learning to use big-O notation.</span>
      </li>
      <li class="li4">
        <span class="s1">Pupils are typically taught standard algorithms for problems in arithmetic and subsequently algebra. This might be as simple as ‘count out the first number of sweets; count out the second number of sweets; now count how many sweets you have’ for integer addition, but will go on to include standard written algorithms for long multiplication and division, as well as methods for solving linear, simultaneous, quadratic and simple differential equations. Pupils are taught standard algorithms in other contexts, including testing for primality. They learn formulae for finding perimeters, areas and volumes, and for solving quadratic equations. Some pupils may discover their own algorithmic approaches to solving some classes of problems.</span>
      </li>
    </ul>
  </li>

  <li class="li4">
    <strong><span class="s1">Decomposition</span></strong> <ul class="ul2">
      <li class="li4">
        <span class="s1">Pupils learn to break down complex problems into smaller ones, tackling each of these in turn. Pupils learn how divide-and-conquer algorithms are applied recursively, efficiently reducing the number of steps needed to solve a problem (e.g. Quicksort). Pupils make use of decomposition in their programming, using procedures, functions or classes to allow the different components of complex software to be developed and tested independently. At the hardware level, pupils come to recognise how digital devices are made of multiple, complex components, each typically made from multiple, complex subsystems.</span>
      </li>
      <li class="li4">
        <span class="s1">Decomposition is also a powerful problem solving technique in mathematics, with pupils applying this in different contexts during their time at school. At an elementary level, pupils recognise how numbers are decomposed into parts using place value, and subsequently prime factors. Simple arithmetic algorithms rely on ready familiarity with decomposition using place value. Pupils learn how the area or volume of complex shapes can be found through decomposition. Subsequently, pupils learn how vectors can be decomposed into orthogonal components and how matrices (and thus systems of linear equations) can be decomposed in a number of ways.</span>
      </li>
    </ul>
  </li>

  <li class="li4">
    <strong><span class="s1">Patterns and generalisation</span></strong> <ul class="ul2">
      <li class="li4">
        <span class="s1">In computing, pupils come to recognise common ways to solve similar problems (for example, drawing equilateral triangles, squares and regular pentagons with a turtle), subsequently developing a general solution to a class of similar problems (in this case, drawing a regular polygon). Pupils learn to use libraries of functions developed by others rather than re-creating this code for themselves. They learn how other programmer’s solutions to problems may be modified to solve similar problems. As pupils’ software projects become more complex, they may make use of design patterns in their work, such as ‘model-view-controller’, which can be applied in a wide range of contexts from computer games to text editors.</span>
      </li>
      <li class="li4">
        <span class="s1">Young children come to recognise patterns at an early stage in mathematics education, colouring in shapes according to a rule or deciding what will come next in a sequence. They generalise their own rules of conservation of number, shape and mass from observation. Later they are introduced to patterns in number, including the times tables as well as common sequences such as square, triangular numbers and the Fibonacci sequence. They conduct mathematical investigations, first describing the rules they discover and then expressing these in algebra, as recurrence relations and then as formulae. Pupils learn generalised algorithms or techniques &#8211; thus pupils learn the algorithm for long multiplication rather than memorising times tables to 100&#215;100 or beyond and standard results for derivatives rather than computing each from first principles.</span>
      </li>
    </ul>
  </li>

  <li class="li4">
    <strong><span class="s1">Abstraction</span></strong> <ul>
      <li class="li4">
        <span class="s1">For Jeanette Wing </span><span class="s3"><a href="https://www.cs.cmu.edu/~CompThink/papers/Wing08a.pdf">abstraction lies at the heart of computational thinking</a>,</span><span class="s1"> and its particular form in computer science serves to distinguish computational thinking from other approaches to problem solving. Computer systems, both hardware and software, are so complex that computer scientists and software engineers have found it essential to establish ways to <i>manage</i> this complexity, by hiding or setting to one side multiple layers of detail. Pupils might first meet abstraction explicitly in the form of ‘computational abstractions which model the state and behaviour of real world systems’ &#8211; for example the motion of a Snooker ball or the spread of an epidemic. They’ll also recognise abstraction in functions, classes, libraries and APIs they use in their code: where the details of implementation are left hidden, and at times inaccessible, behind well documented specifications. They’ll also recognise abstraction in their mental models of computation (or <a href="http://dl.acm.org/citation.cfm?id=2483713"><span class="s5">‘notional machines’</span></a> where the layers of user interface, compiler / interpreter, operating system and the processor’s presentation layer sit between their actions and the copper and silicon of the hardware.</span>
      </li>
      <li class="li4">
        <span class="s1">Abstraction is important in mathematics education too, with the curriculum taking pupils from the concrete to the abstract along a path that would be familiar still to Piaget. At an early age, pupils form an abstract notion of, for example, three-ness from the concrete three bears, three sweets, three books etc. They form an abstract notion of triangle or cube from the experience of particular triangles and cubes. In problem solving, pupils identify the important information in the phrasing of a question, setting to one side the less relevant or irrelevant detail. Algebra might be seen as an abstraction of number, with algebra, geometry, probability and calculus the mathematician’s approach to modelling the state and behaviour of real world systems.</span>
      </li>
    </ul>
  </li>

  <li class="li4">
    <strong><span class="s1">Evaluation</span></strong> <ul>
      <li class="li4">
        <span class="s1">In computing, it’s necessary for pupils to check whether the functions, classes and programs they write produce the results they should. It’s also important that digital artefacts (including, but not limited to, programs) serve their intended purpose and are appropriate for their intended audience, and embody principles of good design. Pupils will also consider the efficiency, and indeed elegance of their code.</span>
      </li>
      <li class="li4">
        <span class="s1">In mathematics, pupils are taught to check their solutions, for example that numbers are broadly of the correct order of magnitude and make sense in the context of the original problem. They are also taught to check their working, that each step of their solution has been carried out correctly. Later on, they’ll learn to look for logical flaws in proofs and perhaps even grasp something of the aesthetics of ‘elegant’ proofs.</span>
      </li>
    </ul>
  </li>
</ul>

<p class="p2">
  <span class="s1">It seems that we could gain much through the language, and perhaps even the approach, of computational thinking within the domain of school mathematics.</span>
</p>

<p class="p2">
  <span class="s1">The concepts of computational thinking can be learnt and applied in ‘unplugged’ approaches, within and beyond computing, without the use of digital technology (as the above comparison with mathematics education illustrates, see also, e.g. <a href="http://csunplugged.org/"><span class="s2">CS Unplugged</span></a>). Wing’s ‘information processing agent’ certainly includes digital computers, but need not be limited to such devices.</span>
</p>

<p class="p2">
  <span class="s1">That said, many would argue that ‘computational thinking’ can be developed particularly (perhaps most) effectively when linked explicitly to the ‘computational doing’ of computer programming:</span>
</p>

> <p class="p4">
>   <span class="s1"><i>Programming plays the same role in computer science that investigations do in maths or science. Programming animates the subject and brings computer science to life; it is creative, and engaging. It illustrates otherwise-abstract concepts in completely concrete terms. It is also an incredibly useful skill. (</i><span class="s5"><i><a href="http://primary.quickstartcomputing.org/resources/pdf/understanding_pos.pdf">Peyton Jones 2014</a>)</i></span></span>
> </p>

<p class="p2">
  <span class="s4"><a href="http://www.arvindguptatoys.com/arvindgupta/mindstorms.pdf">Papert</a></span><span class="s1"> wrote how that he</span>
</p>

> <p class="p4">
>   <span class="s1"><i>began to see how children who had learned to program computers could use very concrete computer models to think about thinking and to learn about learning and in doing so, enhance their powers as psychologists and as epistemologists.</i></span>
> </p>

<p class="p2">
  <span class="s1">The experience of most primary and secondary computing teachers seems to be that computational thinking is best taught when linked with directly with computer programming. It’s possible to argue, as Wolfram does that, if computer programs and computer programming were used more extensively in mathematics education, then this would allow teachers and pupils to focus much more attention on developing mathematical reasoning (or perhaps ‘computational thinking’) rather than mere calculation skills.</span>
</p>

<p class="p2">
  <em>Our sides are below:</em>
</p>
<iframe src="https://docs.google.com/presentation/d/1DgsXcriFW4z1n3BcVl9pmu-Ncc-AoIrMy7G6MdPZX8A/embed?start=false&loop=false&delayms=3000" frameborder="0" width="480" height="299" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
