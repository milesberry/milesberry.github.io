---  

layout: post  
title: "Computing and the computing curriculum"  
date: "2025-09-10 18:00:00 +0000"
author: Miles Berry
permalink: /2025/09/computing-curriculum/
comments: true
image:
        feature: 250910.jpg
---

Computing in school is more than screens and software. At its core lies a simple idea: information goes in, rules act on it, and useful results come out. Early “computers” were people who followed written procedures with paper and pencil. Modern machines do the same work at scale. When pupils grasp this continuity, they see that computing is a disciplined way of turning clear thought into reliable action.

Alan Turing’s model helps. His notional machine reads and writes symbols on a tape, guided by a finite set of states and rules. It is austere, yet it captures the essence of computation. For classroom purposes, this yields two messages. First, the power of a computer rests in the precision of its instructions. Second, the hard part is not pressing run, but deciding what the program must do and proving to yourself that it will do it.

This gives programming its rightful place. Programming is the lab work of computer science. It is where ideas about data, control, and representation meet experience. Pupils who only hear about algorithms never internalise them. Pupils who code without thought learn habits, not insight. The goal is mental execution: before they run a program, they should be able to predict its behaviour from first principles.

The curriculum reform that moved schools from ICT to computing was designed to support this goal. At Key Stage 3 it names three strands. Computer science supplies the foundations: algorithms, logic, data, hardware, and networks. Information technology covers purposeful use: creating artefacts, analysing data, and working across tools and platforms. Digital literacy concerns safe, critical, and ethical participation in a digital society.

In practice, computer science dominates, and GCSE/A level focus on it to the exclusion of the other strands. That bias has costs. If the only certified route is computer science, schools tilt teaching towards examinable content and squeeze time for creative projects and critical evaluation. Mentors can help trainees hold the balance. Keep the foundations strong, but keep the applications and implications alive, so pupils see both the power and the responsibilities that come with it.

The statutory purpose of the wider curriculum also matters. By law, it must be “balanced and broadly based” and prepare pupils for “opportunities, responsibilities, and experiences of later life.” Computing meets that test when we teach knowledge that lasts and methods that transfer. William Morris’s test is a good guide here: include what is useful and what is beautiful. Binary, logic, and networks are useful. Elegant algorithms, neat proofs, and well-crafted programs can be beautiful. A diet of only one leaves the subject thin.

Two features set computing apart. First, the pace of change. Hardware improves, platforms evolve, and practice shifts. The last few years have seen a marked change, with machine learning and large models loosening the tight bond between input, program, and output. In many systems the link is now mediated by a learnt model rather than a hand-written rule. Pupils should know that such models are trained, not told, and that data quality and evaluation are central concerns.

Second, error is normal. Programs break. Assumptions fail. Debugging is not a side topic but a way of thinking. You form a hypothesis about the fault, test it, and refine. The best classes make this visible and safe. When trainees narrate their own debugging, pupils learn how to reason about state, data flow, and control. They also learn to treat mistakes as information rather than shame.

Computational thinking holds these strands together. It is not “thinking like a computer” and it is not a bag of puzzles. It is the act of shaping a problem so that a computer can solve it. Decomposition breaks a problem into tractable parts. Abstraction strips away noise and fixes a clean interface between those parts. Pattern recog­nition spots structure you can reuse. Algorithm design gives a finite, precise process that you can implement and test. These are habits that form through regular coding with feedback. Unplugged activities can warm pupils up, but they should lead into work at the keyboard where ideas meet consequence.

Subject knowledge remains a key challenge. Trainees enter from varied routes, and not all schools can supply a deep bench of specialists. Mentors can make the difference. Help your trainee map the syllabus to core concepts and typical misconceptions. Insist on precise language for state, sequence, selection, and iteration. Encourage small programs that isolate a big idea, then tasks that require pupils to combine ideas in new ways. Model use of trace tables, invariants, and hand simulation. Share your own repertoire of worked examples and “over-the-shoulder” explanations.

Assessment should value process as well as product. Short, frequent checks on reading code are as important as writing it. Ask for predictions before running a program. Ask pupils to explain why a fix works, not only that it works. When pupils study machine learning, ask them to reason about training data, overfitting, and evaluation, not only to click through a tool.

Finally, attend to equity. Girls remain under-represented. The fix is not a pink version of the same lessons. It is a broader picture of what computing is for and who it serves. Show applications in science, art, health, and civic life. Give room for creative outcomes and teamwork. Set up classroom talk that values explanation and care with detail, not only speed. Expect success, and make that expectation visible.

For mentors, the essentials are clear. Keep the foundations in view. Treat programming as laboratory practice. Normalise error and teach debugging. Link theory to purpose. Guard time for creativity and critique. With that stance, your trainee will grow into a teacher who can help pupils understand how computers work, use them with judgment, and build things that are both useful and beautiful.

*Notes for mentors, based on the the second Roehampton PGCE Computing lecture*