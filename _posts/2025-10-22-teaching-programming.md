---  

layout: post  
title: "Teaching programming"  
date: "2025-10-22 18:00:00 +0000"
author: Miles Berry
permalink: /2025/10/teaching-programming/
comments: true
image:
        feature: 251024.jpg
---

This session explored how we can make programming engaging and meaningful for pupils, especially as they move from block-based languages such as Scratch to text-based ones like Python. It examined effective strategies for teaching programming that focus on understanding rather than routine typing.

## Moving Beyond “Hello World”

We began by questioning the familiar tradition of starting with Hello World. Typing a phrase onto the screen has little appeal for most pupils, particularly those who have spent primary school building animations and games in Scratch. For them, moving from interactive projects to a simple text command feels dull and disconnected. This lack of excitement at Key Stage 3 contributes to low take-up of computing later on. Instead of sticking to dry examples, we discussed introducing tasks that connect to pupils’ interests and demonstrate purpose, such as creating small games or visual projects.

The challenge is to design activities that are both motivating and rigorous. Programming lessons can still cover abstraction, algorithms, and data while giving pupils something tangible and fun to work with. Our goal is to balance cognitive stretch with creative engagement.

## Using the PRIMM Framework

A central focus of the lecture was the PRIMM model: Predict, Run, Investigate, Modify, Make. This structure helps pupils move from reading to creating code through stages of engagement. Predicting what a programme will do before running it encourages logical thinking and develops a mental model of computation. Running and investigating then confirm or challenge these predictions. Modifying allows experimentation, while making gives space for originality.

We compared this with other models like Lee's “Use-Modify-Create” and Craig and Dave’s “Try-Investigate-Modify-Make-Evaluate”, which tend to skip the prediction stage. PRIMM’s strength lies in demanding active thought before any code runs. Many of us use this by starting lessons with a short “predict” activity—showing a short code fragment and asking pupils to explain what they expect to happen before we execute it together.

## Reading Before Writing

A strong theme of the session was that pupils’ main difficulty is not writing code but reading it. Research shows that the barrier to learning programming often lies in comprehension. Just as children learn to write by reading first, young programmers must learn to interpret code before producing it themselves.

We discussed ways trainees can give time for reading and reasoning tasks. These might include predicting outcomes, finding errors, or explaining what code does line by line. Such exercises are vital preparation for writing. They develop understanding of syntax, control flow, and logic, which are essential foundations for later creativity.

## Live Coding and PRIMM

We also examined how live coding fits with PRIMM. Live coding—writing and explaining a programme in front of the class—helps trainees model expert thinking. However, it cannot easily coexist with PRIMM’s prediction stage, because the explanation removes the element of uncertainty. The solution is to separate them: use PRIMM with pre-written examples early in the lesson, then move to live coding once pupils have had a chance to reason for themselves. Both approaches are valuable but serve different learning purposes.

## Modelling Real-World Systems

We looked at practical projects that show how programming can model real-world systems. A simple Pong game in Scratch demonstrated how pupils can work with computational abstractions that represent state and behaviour. The example used straightforward physics: the ball bounces between paddles, and pupils can explore how altering formulas affects the behaviour.

This project illustrates how pupils learn by experimenting with representations of physical systems. They can study how the programme works, remix it, and compare different versions—an authentic form of evaluation. These activities meet curriculum aims by encouraging logical reasoning, abstraction, and analysis of alternative algorithms. They also sustain interest through play and creativity.

## Working with Images in Python

We then explored how similar thinking applies in Python through image manipulation. Using the Python Image Library, we adjusted pixel values to explore how digital colour works. This offered a vivid context for loops, data types, and numerical reasoning.

We predicted what would happen when we changed red, green, or blue values, then ran the code to check. We produced greyscale images, colour inversions, and blurred or sharpened versions using convolution matrices. These tasks encourage prediction, investigation, and modification in a concrete and visual way. They also lead naturally into advanced topics such as convolution filters and edge detection—the same principles that underpin modern machine learning.

This progression shows how practical coding exercises can open routes to deeper computer science ideas without losing accessibility.

## Keeping Pupils Interested

Throughout the lecture, we returned to the question of motivation. Pupils’ enjoyment is not a distraction but a key factor in their learning and their decision to continue the subject. Using contexts such as games, graphics, or image filters allows pupils to see how programming connects to their world.

However, it was also clear that our priority as teachers must always be the pupils’ learning, not the trainee’s wish to experiment. Mentors need to help trainees find safe and sensible ways to innovate within the school’s curriculum. Once a trainee has shown secure subject knowledge and classroom management, more freedom can be given to design and adapt lessons.

## The Mentor’s Role

For mentors, the lecture underlined the importance of guiding trainees towards lessons that build comprehension, reasoning, and creativity. Encourage them to use PRIMM or similar structures that let pupils think before they code. Support them in choosing contexts that make programming meaningful, while ensuring alignment with the department’s goals.

Mentors should also help trainees reflect after lessons. What did pupils understand? What misconceptions emerged? How could the next lesson address these? Developing this reflective habit prepares trainees to plan effective sequences of lessons rather than isolated activities.

## Conclusion

Teaching programming is not about memorising syntax. It is about helping pupils form mental models, reason logically, and represent real-world systems through code. Structured approaches such as PRIMM can guide them from reading to making, while engaging projects keep motivation high. As mentors, our task is to help trainees combine rigour with creativity so that pupils learn to see programming not as typing commands but as a way of thinking about the world.  

*Notes for mentors, based on the 6th Roehampton PGCE Computing lecture*